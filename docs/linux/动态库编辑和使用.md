# 动态库编译、链接、使用及异常处理

## 一、使用动态库

### 1. 编码、编译和链接

+ 对于提供了头文件的动态库，可以在编程时直接调用接口函数，在编译链接时指定链接路径和链接库；(链接时指定的路径并不意味着使用时加载动态库的路径);

```bash
# 示例 test.c依赖一个动态库libmyExt.so，该库文件放在当前路径子目录lib下
gcc -o test test.c -L./lib -lmyExt
```

+ 对于没有提供头文件的动态库，只能通过dlopen()等函数来调用



### 2. 运行

​	程序运行时，会自动在系统中搜索动态库路径并加载使用，使用dlopen加载的动态库根据dlopen参数指定路径;



### 3. 异常

	#### 3.1 找不到动态库

​	有时明明动态库就在运行路径下，但却提示找不到动态库***.so;

​	**解决办法**

 + 修改LD_LIBRARY_PATH环境变量
   + 作用： 这个环境变量用于在程序加载运行期间查找动态链接库时指定除了系统默认路径之外的其他路径，注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。
   + 特点： 主要处理临时的动态库加载，LD_LIBRARY_PATH只能对当前用户生效;
 + 修改/etc/ld.so.conf配置文件
   + 作用： /etc/ld.so.conf记录了程序加载运行期间查找动态库的路径;注意，修改了ld.so.conf文件后需要重新加载下这个文件`sudo /sbin/ldconfig -v` or `sudo ldconfig -v`
   + 特点：对所有用户生效，但不是每个操作系统都有这个配置文件;
+ 创建动态库的软链接（推荐）
  + 特点：对所有用户生效，只要是Linux类型的操作系统，都会去/usr/lib目录下去找动态库;
  + 步骤： 1,找到动态库路径`sudo find / -name "[动态库名]"`; 2，创建软链接`ln -s [动态库] [待创建的软链接]`
  + 注意： 
    + 创建软连接的时候要用绝对路径，如果用相对路径，会导致只在当前路径有效，其他路径这个软连接就找不到了;
    + 不建议用cp的方式代替ln -s的方式。原因：当动态库升级的时候，有可能导致动态库版本不一致，还是链接的旧版本



#### 3.2 无法加载动态库

​	有时在加载动态库时提示 "undefined symbol ..."等错误

​	出现这种错误通常是因为依赖缺失，也就是使用的动态库依赖了其他动态库，但找不到;

​	**解决办法**

+ 通过`nm`查看动态库中有哪些未定义的符号`nm --demangle libMyExt.so | grep -v '@@' | grep ' U '`
+ 使用stace查看是哪些动态库加载失败
+ 查看动态库的外部依赖
  + linux: ldd libMyExt.so
  + Mac: otool -L libMyExt.dylib
  + M4: aarch64-linux-android-readelf --dynamic libMyExt.so | grep Shared
  + X1: arm-linux-gnueabihf-readelf --dynamic libMyExt.so | grep Shared

找到了动态库的外部依赖库，根据前面章节介绍的方法在编译和运行前分别链接上即可;



## 二、制作动态库

```
g++ -o libMyExt.so -shared -fPIC test.c # 编译时添加-shared和-fPIC即可
```



